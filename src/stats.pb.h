// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stats.proto

#ifndef PROTOBUF_stats_2eproto__INCLUDED
#define PROTOBUF_stats_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lobstrstats {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_stats_2eproto();
void protobuf_AssignDesc_stats_2eproto();
void protobuf_ShutdownFile_stats_2eproto();

class TrainParams;
class StepSizePDF;
class ModelParams;
class AllelotypeTrainRun;
class PeriodGenotypeCategory;
class ClassifyStats;
class AllelotypeClassifyRun;
class RunInfo;

// ===================================================================

class TrainParams : public ::google::protobuf::Message {
 public:
  TrainParams();
  virtual ~TrainParams();

  TrainParams(const TrainParams& from);

  inline TrainParams& operator=(const TrainParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainParams& default_instance();

  void Swap(TrainParams* other);

  // implements Message ----------------------------------------------

  TrainParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainParams& from);
  void MergeFrom(const TrainParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string haploid_chroms = 1;
  inline bool has_haploid_chroms() const;
  inline void clear_haploid_chroms();
  static const int kHaploidChromsFieldNumber = 1;
  inline const ::std::string& haploid_chroms() const;
  inline void set_haploid_chroms(const ::std::string& value);
  inline void set_haploid_chroms(const char* value);
  inline void set_haploid_chroms(const char* value, size_t size);
  inline ::std::string* mutable_haploid_chroms();
  inline ::std::string* release_haploid_chroms();
  inline void set_allocated_haploid_chroms(::std::string* haploid_chroms);

  // optional int32 num_training_reads = 2;
  inline bool has_num_training_reads() const;
  inline void clear_num_training_reads();
  static const int kNumTrainingReadsFieldNumber = 2;
  inline ::google::protobuf::int32 num_training_reads() const;
  inline void set_num_training_reads(::google::protobuf::int32 value);

  // optional int32 num_discarded_loci = 3;
  inline bool has_num_discarded_loci() const;
  inline void clear_num_discarded_loci();
  static const int kNumDiscardedLociFieldNumber = 3;
  inline ::google::protobuf::int32 num_discarded_loci() const;
  inline void set_num_discarded_loci(::google::protobuf::int32 value);

  // optional int32 num_training_loci = 4;
  inline bool has_num_training_loci() const;
  inline void clear_num_training_loci();
  static const int kNumTrainingLociFieldNumber = 4;
  inline ::google::protobuf::int32 num_training_loci() const;
  inline void set_num_training_loci(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lobstrstats.TrainParams)
 private:
  inline void set_has_haploid_chroms();
  inline void clear_has_haploid_chroms();
  inline void set_has_num_training_reads();
  inline void clear_has_num_training_reads();
  inline void set_has_num_discarded_loci();
  inline void clear_has_num_discarded_loci();
  inline void set_has_num_training_loci();
  inline void clear_has_num_training_loci();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* haploid_chroms_;
  ::google::protobuf::int32 num_training_reads_;
  ::google::protobuf::int32 num_discarded_loci_;
  ::google::protobuf::int32 num_training_loci_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static TrainParams* default_instance_;
};
// -------------------------------------------------------------------

class StepSizePDF : public ::google::protobuf::Message {
 public:
  StepSizePDF();
  virtual ~StepSizePDF();

  StepSizePDF(const StepSizePDF& from);

  inline StepSizePDF& operator=(const StepSizePDF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepSizePDF& default_instance();

  void Swap(StepSizePDF* other);

  // implements Message ----------------------------------------------

  StepSizePDF* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepSizePDF& from);
  void MergeFrom(const StepSizePDF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float prob = 1;
  inline int prob_size() const;
  inline void clear_prob();
  static const int kProbFieldNumber = 1;
  inline float prob(int index) const;
  inline void set_prob(int index, float value);
  inline void add_prob(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      prob() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_prob();

  // repeated int32 observerd = 2;
  inline int observerd_size() const;
  inline void clear_observerd();
  static const int kObserverdFieldNumber = 2;
  inline ::google::protobuf::int32 observerd(int index) const;
  inline void set_observerd(int index, ::google::protobuf::int32 value);
  inline void add_observerd(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      observerd() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_observerd();

  // @@protoc_insertion_point(class_scope:lobstrstats.StepSizePDF)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > prob_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > observerd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static StepSizePDF* default_instance_;
};
// -------------------------------------------------------------------

class ModelParams : public ::google::protobuf::Message {
 public:
  ModelParams();
  virtual ~ModelParams();

  ModelParams(const ModelParams& from);

  inline ModelParams& operator=(const ModelParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelParams& default_instance();

  void Swap(ModelParams* other);

  // implements Message ----------------------------------------------

  ModelParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelParams& from);
  void MergeFrom(const ModelParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float sprob_coef = 1;
  inline int sprob_coef_size() const;
  inline void clear_sprob_coef();
  static const int kSprobCoefFieldNumber = 1;
  inline float sprob_coef(int index) const;
  inline void set_sprob_coef(int index, float value);
  inline void add_sprob_coef(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      sprob_coef() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_sprob_coef();

  // repeated float nonunit_stepsize = 2;
  inline int nonunit_stepsize_size() const;
  inline void clear_nonunit_stepsize();
  static const int kNonunitStepsizeFieldNumber = 2;
  inline float nonunit_stepsize(int index) const;
  inline void set_nonunit_stepsize(int index, float value);
  inline void add_nonunit_stepsize(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      nonunit_stepsize() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_nonunit_stepsize();

  // optional float pincr = 3;
  inline bool has_pincr() const;
  inline void clear_pincr();
  static const int kPincrFieldNumber = 3;
  inline float pincr() const;
  inline void set_pincr(float value);

  // repeated .lobstrstats.StepSizePDF stepsizepdf = 4;
  inline int stepsizepdf_size() const;
  inline void clear_stepsizepdf();
  static const int kStepsizepdfFieldNumber = 4;
  inline const ::lobstrstats::StepSizePDF& stepsizepdf(int index) const;
  inline ::lobstrstats::StepSizePDF* mutable_stepsizepdf(int index);
  inline ::lobstrstats::StepSizePDF* add_stepsizepdf();
  inline const ::google::protobuf::RepeatedPtrField< ::lobstrstats::StepSizePDF >&
      stepsizepdf() const;
  inline ::google::protobuf::RepeatedPtrField< ::lobstrstats::StepSizePDF >*
      mutable_stepsizepdf();

  // @@protoc_insertion_point(class_scope:lobstrstats.ModelParams)
 private:
  inline void set_has_pincr();
  inline void clear_has_pincr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > sprob_coef_;
  ::google::protobuf::RepeatedField< float > nonunit_stepsize_;
  ::google::protobuf::RepeatedPtrField< ::lobstrstats::StepSizePDF > stepsizepdf_;
  float pincr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static ModelParams* default_instance_;
};
// -------------------------------------------------------------------

class AllelotypeTrainRun : public ::google::protobuf::Message {
 public:
  AllelotypeTrainRun();
  virtual ~AllelotypeTrainRun();

  AllelotypeTrainRun(const AllelotypeTrainRun& from);

  inline AllelotypeTrainRun& operator=(const AllelotypeTrainRun& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllelotypeTrainRun& default_instance();

  void Swap(AllelotypeTrainRun* other);

  // implements Message ----------------------------------------------

  AllelotypeTrainRun* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllelotypeTrainRun& from);
  void MergeFrom(const AllelotypeTrainRun& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lobstrstats.TrainParams trainparams = 1;
  inline bool has_trainparams() const;
  inline void clear_trainparams();
  static const int kTrainparamsFieldNumber = 1;
  inline const ::lobstrstats::TrainParams& trainparams() const;
  inline ::lobstrstats::TrainParams* mutable_trainparams();
  inline ::lobstrstats::TrainParams* release_trainparams();
  inline void set_allocated_trainparams(::lobstrstats::TrainParams* trainparams);

  // optional .lobstrstats.ModelParams modelparams = 2;
  inline bool has_modelparams() const;
  inline void clear_modelparams();
  static const int kModelparamsFieldNumber = 2;
  inline const ::lobstrstats::ModelParams& modelparams() const;
  inline ::lobstrstats::ModelParams* mutable_modelparams();
  inline ::lobstrstats::ModelParams* release_modelparams();
  inline void set_allocated_modelparams(::lobstrstats::ModelParams* modelparams);

  // @@protoc_insertion_point(class_scope:lobstrstats.AllelotypeTrainRun)
 private:
  inline void set_has_trainparams();
  inline void clear_has_trainparams();
  inline void set_has_modelparams();
  inline void clear_has_modelparams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lobstrstats::TrainParams* trainparams_;
  ::lobstrstats::ModelParams* modelparams_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static AllelotypeTrainRun* default_instance_;
};
// -------------------------------------------------------------------

class PeriodGenotypeCategory : public ::google::protobuf::Message {
 public:
  PeriodGenotypeCategory();
  virtual ~PeriodGenotypeCategory();

  PeriodGenotypeCategory(const PeriodGenotypeCategory& from);

  inline PeriodGenotypeCategory& operator=(const PeriodGenotypeCategory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeriodGenotypeCategory& default_instance();

  void Swap(PeriodGenotypeCategory* other);

  // implements Message ----------------------------------------------

  PeriodGenotypeCategory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeriodGenotypeCategory& from);
  void MergeFrom(const PeriodGenotypeCategory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 period = 1;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 1;
  inline ::google::protobuf::int32 period() const;
  inline void set_period(::google::protobuf::int32 value);

  // optional float aa = 2;
  inline bool has_aa() const;
  inline void clear_aa();
  static const int kAaFieldNumber = 2;
  inline float aa() const;
  inline void set_aa(float value);

  // optional float ab = 3;
  inline bool has_ab() const;
  inline void clear_ab();
  static const int kAbFieldNumber = 3;
  inline float ab() const;
  inline void set_ab(float value);

  // optional float bb = 4;
  inline bool has_bb() const;
  inline void clear_bb();
  static const int kBbFieldNumber = 4;
  inline float bb() const;
  inline void set_bb(float value);

  // optional float bc = 5;
  inline bool has_bc() const;
  inline void clear_bc();
  static const int kBcFieldNumber = 5;
  inline float bc() const;
  inline void set_bc(float value);

  // @@protoc_insertion_point(class_scope:lobstrstats.PeriodGenotypeCategory)
 private:
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_aa();
  inline void clear_has_aa();
  inline void set_has_ab();
  inline void clear_has_ab();
  inline void set_has_bb();
  inline void clear_has_bb();
  inline void set_has_bc();
  inline void clear_has_bc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 period_;
  float aa_;
  float ab_;
  float bb_;
  float bc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static PeriodGenotypeCategory* default_instance_;
};
// -------------------------------------------------------------------

class ClassifyStats : public ::google::protobuf::Message {
 public:
  ClassifyStats();
  virtual ~ClassifyStats();

  ClassifyStats(const ClassifyStats& from);

  inline ClassifyStats& operator=(const ClassifyStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassifyStats& default_instance();

  void Swap(ClassifyStats* other);

  // implements Message ----------------------------------------------

  ClassifyStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClassifyStats& from);
  void MergeFrom(const ClassifyStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 numcalls = 1;
  inline bool has_numcalls() const;
  inline void clear_numcalls();
  static const int kNumcallsFieldNumber = 1;
  inline ::google::protobuf::int32 numcalls() const;
  inline void set_numcalls(::google::protobuf::int32 value);

  // optional int32 numcalls5x = 2;
  inline bool has_numcalls5x() const;
  inline void clear_numcalls5x();
  static const int kNumcalls5XFieldNumber = 2;
  inline ::google::protobuf::int32 numcalls5x() const;
  inline void set_numcalls5x(::google::protobuf::int32 value);

  // optional int32 numcallsQ9 = 3;
  inline bool has_numcallsq9() const;
  inline void clear_numcallsq9();
  static const int kNumcallsQ9FieldNumber = 3;
  inline ::google::protobuf::int32 numcallsq9() const;
  inline void set_numcallsq9(::google::protobuf::int32 value);

  // optional float meancov = 4;
  inline bool has_meancov() const;
  inline void clear_meancov();
  static const int kMeancovFieldNumber = 4;
  inline float meancov() const;
  inline void set_meancov(float value);

  // optional float meanscore = 6;
  inline bool has_meanscore() const;
  inline void clear_meanscore();
  static const int kMeanscoreFieldNumber = 6;
  inline float meanscore() const;
  inline void set_meanscore(float value);

  // repeated .lobstrstats.PeriodGenotypeCategory pergenotypes = 7;
  inline int pergenotypes_size() const;
  inline void clear_pergenotypes();
  static const int kPergenotypesFieldNumber = 7;
  inline const ::lobstrstats::PeriodGenotypeCategory& pergenotypes(int index) const;
  inline ::lobstrstats::PeriodGenotypeCategory* mutable_pergenotypes(int index);
  inline ::lobstrstats::PeriodGenotypeCategory* add_pergenotypes();
  inline const ::google::protobuf::RepeatedPtrField< ::lobstrstats::PeriodGenotypeCategory >&
      pergenotypes() const;
  inline ::google::protobuf::RepeatedPtrField< ::lobstrstats::PeriodGenotypeCategory >*
      mutable_pergenotypes();

  // @@protoc_insertion_point(class_scope:lobstrstats.ClassifyStats)
 private:
  inline void set_has_numcalls();
  inline void clear_has_numcalls();
  inline void set_has_numcalls5x();
  inline void clear_has_numcalls5x();
  inline void set_has_numcallsq9();
  inline void clear_has_numcallsq9();
  inline void set_has_meancov();
  inline void clear_has_meancov();
  inline void set_has_meanscore();
  inline void clear_has_meanscore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 numcalls_;
  ::google::protobuf::int32 numcalls5x_;
  ::google::protobuf::int32 numcallsq9_;
  float meancov_;
  ::google::protobuf::RepeatedPtrField< ::lobstrstats::PeriodGenotypeCategory > pergenotypes_;
  float meanscore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static ClassifyStats* default_instance_;
};
// -------------------------------------------------------------------

class AllelotypeClassifyRun : public ::google::protobuf::Message {
 public:
  AllelotypeClassifyRun();
  virtual ~AllelotypeClassifyRun();

  AllelotypeClassifyRun(const AllelotypeClassifyRun& from);

  inline AllelotypeClassifyRun& operator=(const AllelotypeClassifyRun& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllelotypeClassifyRun& default_instance();

  void Swap(AllelotypeClassifyRun* other);

  // implements Message ----------------------------------------------

  AllelotypeClassifyRun* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllelotypeClassifyRun& from);
  void MergeFrom(const AllelotypeClassifyRun& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lobstrstats.ModelParams modelparams = 1;
  inline bool has_modelparams() const;
  inline void clear_modelparams();
  static const int kModelparamsFieldNumber = 1;
  inline const ::lobstrstats::ModelParams& modelparams() const;
  inline ::lobstrstats::ModelParams* mutable_modelparams();
  inline ::lobstrstats::ModelParams* release_modelparams();
  inline void set_allocated_modelparams(::lobstrstats::ModelParams* modelparams);

  // optional .lobstrstats.ClassifyStats stats = 2;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 2;
  inline const ::lobstrstats::ClassifyStats& stats() const;
  inline ::lobstrstats::ClassifyStats* mutable_stats();
  inline ::lobstrstats::ClassifyStats* release_stats();
  inline void set_allocated_stats(::lobstrstats::ClassifyStats* stats);

  // @@protoc_insertion_point(class_scope:lobstrstats.AllelotypeClassifyRun)
 private:
  inline void set_has_modelparams();
  inline void clear_has_modelparams();
  inline void set_has_stats();
  inline void clear_has_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lobstrstats::ModelParams* modelparams_;
  ::lobstrstats::ClassifyStats* stats_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static AllelotypeClassifyRun* default_instance_;
};
// -------------------------------------------------------------------

class RunInfo : public ::google::protobuf::Message {
 public:
  RunInfo();
  virtual ~RunInfo();

  RunInfo(const RunInfo& from);

  inline RunInfo& operator=(const RunInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunInfo& default_instance();

  void Swap(RunInfo* other);

  // implements Message ----------------------------------------------

  RunInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunInfo& from);
  void MergeFrom(const RunInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endtime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // optional string params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::std::string& params() const;
  inline void set_params(const ::std::string& value);
  inline void set_params(const char* value);
  inline void set_params(const char* value, size_t size);
  inline ::std::string* mutable_params();
  inline ::std::string* release_params();
  inline void set_allocated_params(::std::string* params);

  // optional string gitversion = 4;
  inline bool has_gitversion() const;
  inline void clear_gitversion();
  static const int kGitversionFieldNumber = 4;
  inline const ::std::string& gitversion() const;
  inline void set_gitversion(const ::std::string& value);
  inline void set_gitversion(const char* value);
  inline void set_gitversion(const char* value, size_t size);
  inline ::std::string* mutable_gitversion();
  inline ::std::string* release_gitversion();
  inline void set_allocated_gitversion(::std::string* gitversion);

  // optional string machtype = 5;
  inline bool has_machtype() const;
  inline void clear_machtype();
  static const int kMachtypeFieldNumber = 5;
  inline const ::std::string& machtype() const;
  inline void set_machtype(const ::std::string& value);
  inline void set_machtype(const char* value);
  inline void set_machtype(const char* value, size_t size);
  inline ::std::string* mutable_machtype();
  inline ::std::string* release_machtype();
  inline void set_allocated_machtype(::std::string* machtype);

  // optional string error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional .lobstrstats.AllelotypeTrainRun trainrun = 7;
  inline bool has_trainrun() const;
  inline void clear_trainrun();
  static const int kTrainrunFieldNumber = 7;
  inline const ::lobstrstats::AllelotypeTrainRun& trainrun() const;
  inline ::lobstrstats::AllelotypeTrainRun* mutable_trainrun();
  inline ::lobstrstats::AllelotypeTrainRun* release_trainrun();
  inline void set_allocated_trainrun(::lobstrstats::AllelotypeTrainRun* trainrun);

  // optional .lobstrstats.AllelotypeClassifyRun classifyrun = 8;
  inline bool has_classifyrun() const;
  inline void clear_classifyrun();
  static const int kClassifyrunFieldNumber = 8;
  inline const ::lobstrstats::AllelotypeClassifyRun& classifyrun() const;
  inline ::lobstrstats::AllelotypeClassifyRun* mutable_classifyrun();
  inline ::lobstrstats::AllelotypeClassifyRun* release_classifyrun();
  inline void set_allocated_classifyrun(::lobstrstats::AllelotypeClassifyRun* classifyrun);

  // @@protoc_insertion_point(class_scope:lobstrstats.RunInfo)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_params();
  inline void clear_has_params();
  inline void set_has_gitversion();
  inline void clear_has_gitversion();
  inline void set_has_machtype();
  inline void clear_has_machtype();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_trainrun();
  inline void clear_has_trainrun();
  inline void set_has_classifyrun();
  inline void clear_has_classifyrun();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;
  ::std::string* params_;
  ::std::string* gitversion_;
  ::std::string* machtype_;
  ::std::string* error_;
  ::lobstrstats::AllelotypeTrainRun* trainrun_;
  ::lobstrstats::AllelotypeClassifyRun* classifyrun_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_stats_2eproto();
  friend void protobuf_AssignDesc_stats_2eproto();
  friend void protobuf_ShutdownFile_stats_2eproto();

  void InitAsDefaultInstance();
  static RunInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// TrainParams

// optional string haploid_chroms = 1;
inline bool TrainParams::has_haploid_chroms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainParams::set_has_haploid_chroms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainParams::clear_has_haploid_chroms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainParams::clear_haploid_chroms() {
  if (haploid_chroms_ != &::google::protobuf::internal::kEmptyString) {
    haploid_chroms_->clear();
  }
  clear_has_haploid_chroms();
}
inline const ::std::string& TrainParams::haploid_chroms() const {
  return *haploid_chroms_;
}
inline void TrainParams::set_haploid_chroms(const ::std::string& value) {
  set_has_haploid_chroms();
  if (haploid_chroms_ == &::google::protobuf::internal::kEmptyString) {
    haploid_chroms_ = new ::std::string;
  }
  haploid_chroms_->assign(value);
}
inline void TrainParams::set_haploid_chroms(const char* value) {
  set_has_haploid_chroms();
  if (haploid_chroms_ == &::google::protobuf::internal::kEmptyString) {
    haploid_chroms_ = new ::std::string;
  }
  haploid_chroms_->assign(value);
}
inline void TrainParams::set_haploid_chroms(const char* value, size_t size) {
  set_has_haploid_chroms();
  if (haploid_chroms_ == &::google::protobuf::internal::kEmptyString) {
    haploid_chroms_ = new ::std::string;
  }
  haploid_chroms_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainParams::mutable_haploid_chroms() {
  set_has_haploid_chroms();
  if (haploid_chroms_ == &::google::protobuf::internal::kEmptyString) {
    haploid_chroms_ = new ::std::string;
  }
  return haploid_chroms_;
}
inline ::std::string* TrainParams::release_haploid_chroms() {
  clear_has_haploid_chroms();
  if (haploid_chroms_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = haploid_chroms_;
    haploid_chroms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrainParams::set_allocated_haploid_chroms(::std::string* haploid_chroms) {
  if (haploid_chroms_ != &::google::protobuf::internal::kEmptyString) {
    delete haploid_chroms_;
  }
  if (haploid_chroms) {
    set_has_haploid_chroms();
    haploid_chroms_ = haploid_chroms;
  } else {
    clear_has_haploid_chroms();
    haploid_chroms_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num_training_reads = 2;
inline bool TrainParams::has_num_training_reads() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainParams::set_has_num_training_reads() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainParams::clear_has_num_training_reads() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainParams::clear_num_training_reads() {
  num_training_reads_ = 0;
  clear_has_num_training_reads();
}
inline ::google::protobuf::int32 TrainParams::num_training_reads() const {
  return num_training_reads_;
}
inline void TrainParams::set_num_training_reads(::google::protobuf::int32 value) {
  set_has_num_training_reads();
  num_training_reads_ = value;
}

// optional int32 num_discarded_loci = 3;
inline bool TrainParams::has_num_discarded_loci() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainParams::set_has_num_discarded_loci() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainParams::clear_has_num_discarded_loci() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainParams::clear_num_discarded_loci() {
  num_discarded_loci_ = 0;
  clear_has_num_discarded_loci();
}
inline ::google::protobuf::int32 TrainParams::num_discarded_loci() const {
  return num_discarded_loci_;
}
inline void TrainParams::set_num_discarded_loci(::google::protobuf::int32 value) {
  set_has_num_discarded_loci();
  num_discarded_loci_ = value;
}

// optional int32 num_training_loci = 4;
inline bool TrainParams::has_num_training_loci() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrainParams::set_has_num_training_loci() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrainParams::clear_has_num_training_loci() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrainParams::clear_num_training_loci() {
  num_training_loci_ = 0;
  clear_has_num_training_loci();
}
inline ::google::protobuf::int32 TrainParams::num_training_loci() const {
  return num_training_loci_;
}
inline void TrainParams::set_num_training_loci(::google::protobuf::int32 value) {
  set_has_num_training_loci();
  num_training_loci_ = value;
}

// -------------------------------------------------------------------

// StepSizePDF

// repeated float prob = 1;
inline int StepSizePDF::prob_size() const {
  return prob_.size();
}
inline void StepSizePDF::clear_prob() {
  prob_.Clear();
}
inline float StepSizePDF::prob(int index) const {
  return prob_.Get(index);
}
inline void StepSizePDF::set_prob(int index, float value) {
  prob_.Set(index, value);
}
inline void StepSizePDF::add_prob(float value) {
  prob_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
StepSizePDF::prob() const {
  return prob_;
}
inline ::google::protobuf::RepeatedField< float >*
StepSizePDF::mutable_prob() {
  return &prob_;
}

// repeated int32 observerd = 2;
inline int StepSizePDF::observerd_size() const {
  return observerd_.size();
}
inline void StepSizePDF::clear_observerd() {
  observerd_.Clear();
}
inline ::google::protobuf::int32 StepSizePDF::observerd(int index) const {
  return observerd_.Get(index);
}
inline void StepSizePDF::set_observerd(int index, ::google::protobuf::int32 value) {
  observerd_.Set(index, value);
}
inline void StepSizePDF::add_observerd(::google::protobuf::int32 value) {
  observerd_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
StepSizePDF::observerd() const {
  return observerd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
StepSizePDF::mutable_observerd() {
  return &observerd_;
}

// -------------------------------------------------------------------

// ModelParams

// repeated float sprob_coef = 1;
inline int ModelParams::sprob_coef_size() const {
  return sprob_coef_.size();
}
inline void ModelParams::clear_sprob_coef() {
  sprob_coef_.Clear();
}
inline float ModelParams::sprob_coef(int index) const {
  return sprob_coef_.Get(index);
}
inline void ModelParams::set_sprob_coef(int index, float value) {
  sprob_coef_.Set(index, value);
}
inline void ModelParams::add_sprob_coef(float value) {
  sprob_coef_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelParams::sprob_coef() const {
  return sprob_coef_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelParams::mutable_sprob_coef() {
  return &sprob_coef_;
}

// repeated float nonunit_stepsize = 2;
inline int ModelParams::nonunit_stepsize_size() const {
  return nonunit_stepsize_.size();
}
inline void ModelParams::clear_nonunit_stepsize() {
  nonunit_stepsize_.Clear();
}
inline float ModelParams::nonunit_stepsize(int index) const {
  return nonunit_stepsize_.Get(index);
}
inline void ModelParams::set_nonunit_stepsize(int index, float value) {
  nonunit_stepsize_.Set(index, value);
}
inline void ModelParams::add_nonunit_stepsize(float value) {
  nonunit_stepsize_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ModelParams::nonunit_stepsize() const {
  return nonunit_stepsize_;
}
inline ::google::protobuf::RepeatedField< float >*
ModelParams::mutable_nonunit_stepsize() {
  return &nonunit_stepsize_;
}

// optional float pincr = 3;
inline bool ModelParams::has_pincr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelParams::set_has_pincr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelParams::clear_has_pincr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelParams::clear_pincr() {
  pincr_ = 0;
  clear_has_pincr();
}
inline float ModelParams::pincr() const {
  return pincr_;
}
inline void ModelParams::set_pincr(float value) {
  set_has_pincr();
  pincr_ = value;
}

// repeated .lobstrstats.StepSizePDF stepsizepdf = 4;
inline int ModelParams::stepsizepdf_size() const {
  return stepsizepdf_.size();
}
inline void ModelParams::clear_stepsizepdf() {
  stepsizepdf_.Clear();
}
inline const ::lobstrstats::StepSizePDF& ModelParams::stepsizepdf(int index) const {
  return stepsizepdf_.Get(index);
}
inline ::lobstrstats::StepSizePDF* ModelParams::mutable_stepsizepdf(int index) {
  return stepsizepdf_.Mutable(index);
}
inline ::lobstrstats::StepSizePDF* ModelParams::add_stepsizepdf() {
  return stepsizepdf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lobstrstats::StepSizePDF >&
ModelParams::stepsizepdf() const {
  return stepsizepdf_;
}
inline ::google::protobuf::RepeatedPtrField< ::lobstrstats::StepSizePDF >*
ModelParams::mutable_stepsizepdf() {
  return &stepsizepdf_;
}

// -------------------------------------------------------------------

// AllelotypeTrainRun

// optional .lobstrstats.TrainParams trainparams = 1;
inline bool AllelotypeTrainRun::has_trainparams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllelotypeTrainRun::set_has_trainparams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllelotypeTrainRun::clear_has_trainparams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllelotypeTrainRun::clear_trainparams() {
  if (trainparams_ != NULL) trainparams_->::lobstrstats::TrainParams::Clear();
  clear_has_trainparams();
}
inline const ::lobstrstats::TrainParams& AllelotypeTrainRun::trainparams() const {
  return trainparams_ != NULL ? *trainparams_ : *default_instance_->trainparams_;
}
inline ::lobstrstats::TrainParams* AllelotypeTrainRun::mutable_trainparams() {
  set_has_trainparams();
  if (trainparams_ == NULL) trainparams_ = new ::lobstrstats::TrainParams;
  return trainparams_;
}
inline ::lobstrstats::TrainParams* AllelotypeTrainRun::release_trainparams() {
  clear_has_trainparams();
  ::lobstrstats::TrainParams* temp = trainparams_;
  trainparams_ = NULL;
  return temp;
}
inline void AllelotypeTrainRun::set_allocated_trainparams(::lobstrstats::TrainParams* trainparams) {
  delete trainparams_;
  trainparams_ = trainparams;
  if (trainparams) {
    set_has_trainparams();
  } else {
    clear_has_trainparams();
  }
}

// optional .lobstrstats.ModelParams modelparams = 2;
inline bool AllelotypeTrainRun::has_modelparams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllelotypeTrainRun::set_has_modelparams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllelotypeTrainRun::clear_has_modelparams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllelotypeTrainRun::clear_modelparams() {
  if (modelparams_ != NULL) modelparams_->::lobstrstats::ModelParams::Clear();
  clear_has_modelparams();
}
inline const ::lobstrstats::ModelParams& AllelotypeTrainRun::modelparams() const {
  return modelparams_ != NULL ? *modelparams_ : *default_instance_->modelparams_;
}
inline ::lobstrstats::ModelParams* AllelotypeTrainRun::mutable_modelparams() {
  set_has_modelparams();
  if (modelparams_ == NULL) modelparams_ = new ::lobstrstats::ModelParams;
  return modelparams_;
}
inline ::lobstrstats::ModelParams* AllelotypeTrainRun::release_modelparams() {
  clear_has_modelparams();
  ::lobstrstats::ModelParams* temp = modelparams_;
  modelparams_ = NULL;
  return temp;
}
inline void AllelotypeTrainRun::set_allocated_modelparams(::lobstrstats::ModelParams* modelparams) {
  delete modelparams_;
  modelparams_ = modelparams;
  if (modelparams) {
    set_has_modelparams();
  } else {
    clear_has_modelparams();
  }
}

// -------------------------------------------------------------------

// PeriodGenotypeCategory

// optional int32 period = 1;
inline bool PeriodGenotypeCategory::has_period() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeriodGenotypeCategory::set_has_period() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeriodGenotypeCategory::clear_has_period() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeriodGenotypeCategory::clear_period() {
  period_ = 0;
  clear_has_period();
}
inline ::google::protobuf::int32 PeriodGenotypeCategory::period() const {
  return period_;
}
inline void PeriodGenotypeCategory::set_period(::google::protobuf::int32 value) {
  set_has_period();
  period_ = value;
}

// optional float aa = 2;
inline bool PeriodGenotypeCategory::has_aa() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeriodGenotypeCategory::set_has_aa() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeriodGenotypeCategory::clear_has_aa() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeriodGenotypeCategory::clear_aa() {
  aa_ = 0;
  clear_has_aa();
}
inline float PeriodGenotypeCategory::aa() const {
  return aa_;
}
inline void PeriodGenotypeCategory::set_aa(float value) {
  set_has_aa();
  aa_ = value;
}

// optional float ab = 3;
inline bool PeriodGenotypeCategory::has_ab() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeriodGenotypeCategory::set_has_ab() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeriodGenotypeCategory::clear_has_ab() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeriodGenotypeCategory::clear_ab() {
  ab_ = 0;
  clear_has_ab();
}
inline float PeriodGenotypeCategory::ab() const {
  return ab_;
}
inline void PeriodGenotypeCategory::set_ab(float value) {
  set_has_ab();
  ab_ = value;
}

// optional float bb = 4;
inline bool PeriodGenotypeCategory::has_bb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PeriodGenotypeCategory::set_has_bb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PeriodGenotypeCategory::clear_has_bb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PeriodGenotypeCategory::clear_bb() {
  bb_ = 0;
  clear_has_bb();
}
inline float PeriodGenotypeCategory::bb() const {
  return bb_;
}
inline void PeriodGenotypeCategory::set_bb(float value) {
  set_has_bb();
  bb_ = value;
}

// optional float bc = 5;
inline bool PeriodGenotypeCategory::has_bc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PeriodGenotypeCategory::set_has_bc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PeriodGenotypeCategory::clear_has_bc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PeriodGenotypeCategory::clear_bc() {
  bc_ = 0;
  clear_has_bc();
}
inline float PeriodGenotypeCategory::bc() const {
  return bc_;
}
inline void PeriodGenotypeCategory::set_bc(float value) {
  set_has_bc();
  bc_ = value;
}

// -------------------------------------------------------------------

// ClassifyStats

// optional int32 numcalls = 1;
inline bool ClassifyStats::has_numcalls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClassifyStats::set_has_numcalls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClassifyStats::clear_has_numcalls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClassifyStats::clear_numcalls() {
  numcalls_ = 0;
  clear_has_numcalls();
}
inline ::google::protobuf::int32 ClassifyStats::numcalls() const {
  return numcalls_;
}
inline void ClassifyStats::set_numcalls(::google::protobuf::int32 value) {
  set_has_numcalls();
  numcalls_ = value;
}

// optional int32 numcalls5x = 2;
inline bool ClassifyStats::has_numcalls5x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClassifyStats::set_has_numcalls5x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClassifyStats::clear_has_numcalls5x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClassifyStats::clear_numcalls5x() {
  numcalls5x_ = 0;
  clear_has_numcalls5x();
}
inline ::google::protobuf::int32 ClassifyStats::numcalls5x() const {
  return numcalls5x_;
}
inline void ClassifyStats::set_numcalls5x(::google::protobuf::int32 value) {
  set_has_numcalls5x();
  numcalls5x_ = value;
}

// optional int32 numcallsQ9 = 3;
inline bool ClassifyStats::has_numcallsq9() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClassifyStats::set_has_numcallsq9() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClassifyStats::clear_has_numcallsq9() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClassifyStats::clear_numcallsq9() {
  numcallsq9_ = 0;
  clear_has_numcallsq9();
}
inline ::google::protobuf::int32 ClassifyStats::numcallsq9() const {
  return numcallsq9_;
}
inline void ClassifyStats::set_numcallsq9(::google::protobuf::int32 value) {
  set_has_numcallsq9();
  numcallsq9_ = value;
}

// optional float meancov = 4;
inline bool ClassifyStats::has_meancov() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClassifyStats::set_has_meancov() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClassifyStats::clear_has_meancov() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClassifyStats::clear_meancov() {
  meancov_ = 0;
  clear_has_meancov();
}
inline float ClassifyStats::meancov() const {
  return meancov_;
}
inline void ClassifyStats::set_meancov(float value) {
  set_has_meancov();
  meancov_ = value;
}

// optional float meanscore = 6;
inline bool ClassifyStats::has_meanscore() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClassifyStats::set_has_meanscore() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClassifyStats::clear_has_meanscore() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClassifyStats::clear_meanscore() {
  meanscore_ = 0;
  clear_has_meanscore();
}
inline float ClassifyStats::meanscore() const {
  return meanscore_;
}
inline void ClassifyStats::set_meanscore(float value) {
  set_has_meanscore();
  meanscore_ = value;
}

// repeated .lobstrstats.PeriodGenotypeCategory pergenotypes = 7;
inline int ClassifyStats::pergenotypes_size() const {
  return pergenotypes_.size();
}
inline void ClassifyStats::clear_pergenotypes() {
  pergenotypes_.Clear();
}
inline const ::lobstrstats::PeriodGenotypeCategory& ClassifyStats::pergenotypes(int index) const {
  return pergenotypes_.Get(index);
}
inline ::lobstrstats::PeriodGenotypeCategory* ClassifyStats::mutable_pergenotypes(int index) {
  return pergenotypes_.Mutable(index);
}
inline ::lobstrstats::PeriodGenotypeCategory* ClassifyStats::add_pergenotypes() {
  return pergenotypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lobstrstats::PeriodGenotypeCategory >&
ClassifyStats::pergenotypes() const {
  return pergenotypes_;
}
inline ::google::protobuf::RepeatedPtrField< ::lobstrstats::PeriodGenotypeCategory >*
ClassifyStats::mutable_pergenotypes() {
  return &pergenotypes_;
}

// -------------------------------------------------------------------

// AllelotypeClassifyRun

// optional .lobstrstats.ModelParams modelparams = 1;
inline bool AllelotypeClassifyRun::has_modelparams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllelotypeClassifyRun::set_has_modelparams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllelotypeClassifyRun::clear_has_modelparams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllelotypeClassifyRun::clear_modelparams() {
  if (modelparams_ != NULL) modelparams_->::lobstrstats::ModelParams::Clear();
  clear_has_modelparams();
}
inline const ::lobstrstats::ModelParams& AllelotypeClassifyRun::modelparams() const {
  return modelparams_ != NULL ? *modelparams_ : *default_instance_->modelparams_;
}
inline ::lobstrstats::ModelParams* AllelotypeClassifyRun::mutable_modelparams() {
  set_has_modelparams();
  if (modelparams_ == NULL) modelparams_ = new ::lobstrstats::ModelParams;
  return modelparams_;
}
inline ::lobstrstats::ModelParams* AllelotypeClassifyRun::release_modelparams() {
  clear_has_modelparams();
  ::lobstrstats::ModelParams* temp = modelparams_;
  modelparams_ = NULL;
  return temp;
}
inline void AllelotypeClassifyRun::set_allocated_modelparams(::lobstrstats::ModelParams* modelparams) {
  delete modelparams_;
  modelparams_ = modelparams;
  if (modelparams) {
    set_has_modelparams();
  } else {
    clear_has_modelparams();
  }
}

// optional .lobstrstats.ClassifyStats stats = 2;
inline bool AllelotypeClassifyRun::has_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllelotypeClassifyRun::set_has_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllelotypeClassifyRun::clear_has_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllelotypeClassifyRun::clear_stats() {
  if (stats_ != NULL) stats_->::lobstrstats::ClassifyStats::Clear();
  clear_has_stats();
}
inline const ::lobstrstats::ClassifyStats& AllelotypeClassifyRun::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::lobstrstats::ClassifyStats* AllelotypeClassifyRun::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::lobstrstats::ClassifyStats;
  return stats_;
}
inline ::lobstrstats::ClassifyStats* AllelotypeClassifyRun::release_stats() {
  clear_has_stats();
  ::lobstrstats::ClassifyStats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void AllelotypeClassifyRun::set_allocated_stats(::lobstrstats::ClassifyStats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// -------------------------------------------------------------------

// RunInfo

// optional string starttime = 1;
inline bool RunInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunInfo::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& RunInfo::starttime() const {
  return *starttime_;
}
inline void RunInfo::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void RunInfo::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void RunInfo::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* RunInfo::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endtime = 2;
inline bool RunInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunInfo::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& RunInfo::endtime() const {
  return *endtime_;
}
inline void RunInfo::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void RunInfo::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void RunInfo::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* RunInfo::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string params = 3;
inline bool RunInfo::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunInfo::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunInfo::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunInfo::clear_params() {
  if (params_ != &::google::protobuf::internal::kEmptyString) {
    params_->clear();
  }
  clear_has_params();
}
inline const ::std::string& RunInfo::params() const {
  return *params_;
}
inline void RunInfo::set_params(const ::std::string& value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(value);
}
inline void RunInfo::set_params(const char* value) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(value);
}
inline void RunInfo::set_params(const char* value, size_t size) {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  params_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_params() {
  set_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    params_ = new ::std::string;
  }
  return params_;
}
inline ::std::string* RunInfo::release_params() {
  clear_has_params();
  if (params_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = params_;
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_params(::std::string* params) {
  if (params_ != &::google::protobuf::internal::kEmptyString) {
    delete params_;
  }
  if (params) {
    set_has_params();
    params_ = params;
  } else {
    clear_has_params();
    params_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gitversion = 4;
inline bool RunInfo::has_gitversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RunInfo::set_has_gitversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RunInfo::clear_has_gitversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RunInfo::clear_gitversion() {
  if (gitversion_ != &::google::protobuf::internal::kEmptyString) {
    gitversion_->clear();
  }
  clear_has_gitversion();
}
inline const ::std::string& RunInfo::gitversion() const {
  return *gitversion_;
}
inline void RunInfo::set_gitversion(const ::std::string& value) {
  set_has_gitversion();
  if (gitversion_ == &::google::protobuf::internal::kEmptyString) {
    gitversion_ = new ::std::string;
  }
  gitversion_->assign(value);
}
inline void RunInfo::set_gitversion(const char* value) {
  set_has_gitversion();
  if (gitversion_ == &::google::protobuf::internal::kEmptyString) {
    gitversion_ = new ::std::string;
  }
  gitversion_->assign(value);
}
inline void RunInfo::set_gitversion(const char* value, size_t size) {
  set_has_gitversion();
  if (gitversion_ == &::google::protobuf::internal::kEmptyString) {
    gitversion_ = new ::std::string;
  }
  gitversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_gitversion() {
  set_has_gitversion();
  if (gitversion_ == &::google::protobuf::internal::kEmptyString) {
    gitversion_ = new ::std::string;
  }
  return gitversion_;
}
inline ::std::string* RunInfo::release_gitversion() {
  clear_has_gitversion();
  if (gitversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gitversion_;
    gitversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_gitversion(::std::string* gitversion) {
  if (gitversion_ != &::google::protobuf::internal::kEmptyString) {
    delete gitversion_;
  }
  if (gitversion) {
    set_has_gitversion();
    gitversion_ = gitversion;
  } else {
    clear_has_gitversion();
    gitversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machtype = 5;
inline bool RunInfo::has_machtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunInfo::set_has_machtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunInfo::clear_has_machtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunInfo::clear_machtype() {
  if (machtype_ != &::google::protobuf::internal::kEmptyString) {
    machtype_->clear();
  }
  clear_has_machtype();
}
inline const ::std::string& RunInfo::machtype() const {
  return *machtype_;
}
inline void RunInfo::set_machtype(const ::std::string& value) {
  set_has_machtype();
  if (machtype_ == &::google::protobuf::internal::kEmptyString) {
    machtype_ = new ::std::string;
  }
  machtype_->assign(value);
}
inline void RunInfo::set_machtype(const char* value) {
  set_has_machtype();
  if (machtype_ == &::google::protobuf::internal::kEmptyString) {
    machtype_ = new ::std::string;
  }
  machtype_->assign(value);
}
inline void RunInfo::set_machtype(const char* value, size_t size) {
  set_has_machtype();
  if (machtype_ == &::google::protobuf::internal::kEmptyString) {
    machtype_ = new ::std::string;
  }
  machtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_machtype() {
  set_has_machtype();
  if (machtype_ == &::google::protobuf::internal::kEmptyString) {
    machtype_ = new ::std::string;
  }
  return machtype_;
}
inline ::std::string* RunInfo::release_machtype() {
  clear_has_machtype();
  if (machtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machtype_;
    machtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_machtype(::std::string* machtype) {
  if (machtype_ != &::google::protobuf::internal::kEmptyString) {
    delete machtype_;
  }
  if (machtype) {
    set_has_machtype();
    machtype_ = machtype;
  } else {
    clear_has_machtype();
    machtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error = 6;
inline bool RunInfo::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RunInfo::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RunInfo::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RunInfo::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& RunInfo::error() const {
  return *error_;
}
inline void RunInfo::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void RunInfo::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void RunInfo::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunInfo::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* RunInfo::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RunInfo::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .lobstrstats.AllelotypeTrainRun trainrun = 7;
inline bool RunInfo::has_trainrun() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RunInfo::set_has_trainrun() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RunInfo::clear_has_trainrun() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RunInfo::clear_trainrun() {
  if (trainrun_ != NULL) trainrun_->::lobstrstats::AllelotypeTrainRun::Clear();
  clear_has_trainrun();
}
inline const ::lobstrstats::AllelotypeTrainRun& RunInfo::trainrun() const {
  return trainrun_ != NULL ? *trainrun_ : *default_instance_->trainrun_;
}
inline ::lobstrstats::AllelotypeTrainRun* RunInfo::mutable_trainrun() {
  set_has_trainrun();
  if (trainrun_ == NULL) trainrun_ = new ::lobstrstats::AllelotypeTrainRun;
  return trainrun_;
}
inline ::lobstrstats::AllelotypeTrainRun* RunInfo::release_trainrun() {
  clear_has_trainrun();
  ::lobstrstats::AllelotypeTrainRun* temp = trainrun_;
  trainrun_ = NULL;
  return temp;
}
inline void RunInfo::set_allocated_trainrun(::lobstrstats::AllelotypeTrainRun* trainrun) {
  delete trainrun_;
  trainrun_ = trainrun;
  if (trainrun) {
    set_has_trainrun();
  } else {
    clear_has_trainrun();
  }
}

// optional .lobstrstats.AllelotypeClassifyRun classifyrun = 8;
inline bool RunInfo::has_classifyrun() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RunInfo::set_has_classifyrun() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RunInfo::clear_has_classifyrun() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RunInfo::clear_classifyrun() {
  if (classifyrun_ != NULL) classifyrun_->::lobstrstats::AllelotypeClassifyRun::Clear();
  clear_has_classifyrun();
}
inline const ::lobstrstats::AllelotypeClassifyRun& RunInfo::classifyrun() const {
  return classifyrun_ != NULL ? *classifyrun_ : *default_instance_->classifyrun_;
}
inline ::lobstrstats::AllelotypeClassifyRun* RunInfo::mutable_classifyrun() {
  set_has_classifyrun();
  if (classifyrun_ == NULL) classifyrun_ = new ::lobstrstats::AllelotypeClassifyRun;
  return classifyrun_;
}
inline ::lobstrstats::AllelotypeClassifyRun* RunInfo::release_classifyrun() {
  clear_has_classifyrun();
  ::lobstrstats::AllelotypeClassifyRun* temp = classifyrun_;
  classifyrun_ = NULL;
  return temp;
}
inline void RunInfo::set_allocated_classifyrun(::lobstrstats::AllelotypeClassifyRun* classifyrun) {
  delete classifyrun_;
  classifyrun_ = classifyrun;
  if (classifyrun) {
    set_has_classifyrun();
  } else {
    clear_has_classifyrun();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lobstrstats

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_stats_2eproto__INCLUDED
